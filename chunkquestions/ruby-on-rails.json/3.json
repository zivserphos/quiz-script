[{"query":" Q50. Which choice is not a valid Rails route?","options":[" route \"products/index\", to: \"products/index\", via: :get\r\n"," match \"products/index\", to: \"products#index\", via: :get\r\n"," root \"products/index\"\r\n"," get \"products/index\"\r\n\r\n"],"correctAns":1},{"query":" Q51. Given a table of blog_posts and a related table of comments (comments made on each blog post), which ActiveRecord query will retrieve all blog posts with comments created during @range?","options":[" BlogPost.joins (:comments).where(comments: {created_at: @range})\r\n"," BlogPost.where(['comments.created_at', @range])\r\n"," BlogPost.preload (\"comments.created_at\").where(created_at: @range)\r\n"," BlogPost.includes (:comments).where('comments.created_at' => @range)\r\n\r\n"],"correctAns":1},{"query":" Q52. Given this Category model with an attribute for \"name\", what code would fill in the blank so that it sets saved_name to a string that is the category name that existed before the name was changed?","code":"ruby\r\nclass Category < ActiveRecord::Base\r\n  # has a database column for :name\r\nend\r\n\r\ncategory = Category.first\r\ncategory.name = 'News'\r\nsaved_name = _____\r\n","options":[" category.name_was\r\n"," category.saved(:name)\r\n"," category.changes[:name]\r\n"," category.name_changed?\r\n\r\n"],"correctAns":3},{"query":" Q53. Given two models, what is the issue with the query used to fetch them?","code":"ruby\r\nclass LineItem < ApplicationRecord\r\nend\r\n\r\nclass Order < ApplicationRecord\r\n  has_many :line_items\r\nend\r\n\r\nOrder.limit(3).each { |order| puts order.line_items }\r\n","options":[" This query will result in extensive caching, and you will have to then deal with caching issues.\r\n"," This query will result in the N+1 query issue. Three orders will result in four queries.\r\n"," This query will result in the 1 query issue. Three orders will result in one query.\r\n"," There are no issues with this query, and you are correctly limiting the number of Order models that will be loaded.\r\n\r\n"],"correctAns":2},{"query":" Q54. Which choice is an _incorrect_ way to render a partial?","options":[" `<%= render(:partial => 'shared/product') %>`\r\n"," `<%= render('shared/product', :collection => @products) %>`\r\n"," `<%= render(template: 'shared/product', with: @products) %>`\r\n"," `<%= render('shared/product', locals: { product: @product }) %>`\r\n\r\n"],"correctAns":3},{"query":" Q55. Which code sample will skip running the `login_required` \"before\" filter on the `get_posts` controller action?","options":[" `before_action :login_required, skip: [:get_posts]`\r\n"," `skip_before_action :login_required, except: [:get_posts]`\r\n"," `skip_before_action :login_required, only: [:get_posts]`\r\n"," `skip_action before: :login_required, only: [:get_posts]`\r\n\r\n"],"correctAns":3},{"query":" Q56. Within a Rails model with a `cache_key` method, which code snippet will expire the cache whenever the model is updated?","code":null,"options":[" A\r\n\r\n```ruby\r\nafter_update_commit do\r\ndestroy\r\nend\r\n```\r\n\r\n"," B\r\n\r\n```ruby\r\nafter_destroy do\r\nRails.cache.delete(cache_key)\r\nend\r\n```\r\n\r\n"," C\r\n\r\n```ruby\r\nafter_update_commit do\r\nRails.cache.delete(cache_key)\r\nend\r\n```\r\n\r\n"," D\r\n\r\n```ruby\r\nafter_update_commit do\r\nRails.cache.destroy(cache_key)\r\nend\r\n```\r\n\r\n"],"correctAns":4},{"query":" Q57. After this migration has been executed, which statement would be true?","code":"ruby\r\nclass CreateGalleries < ActiveRecord::Migration\r\n  def change\r\n    create_table :galleries do |t|\r\n      t.string :name, :bg_color\r\n      t.integer :position\r\n      t.boolean :visible, default: false\r\n      t.timestamps\r\n    end\r\n  end\r\nend\r\n","options":[" The galleries table will have no primary key.\r\n"," The galleries table will include a column named \"updated_at\".\r\n"," The galleries table will contain exactly seven columns.\r\n"," The galleries table will have an index on the position column.\r\n\r\n"],"correctAns":2},{"query":" Q58. Which code would you add to return a 404 to the API caller if the user is not found in the database?","code":"ruby\r\nclass UsersController < ApplicationController\r\n  def show\r\n    @user = User.find(params[:id])\r\n    render json: @user, status: :ok,\r\n    # Missing code\r\nend\r\n","options":[" A\r\n\r\n```ruby\r\nrescue => e\r\n  logger.info e\r\nend\r\n```\r\n\r\n"," B\r\n\r\n```ruby\r\nrescue_from ActiveRecord::RecordNotFound, with: :render_not_found_response\r\n```\r\n\r\n"," C\r\n\r\n```ruby\r\nrescue ActiveRecord::RecordNotFound\r\n  render json: { message: 'User not found' }, status: :not_found\r\nend\r\n```\r\n\r\n"," D\r\n\r\n```ruby\r\nraise ActiveRecord::RecordNotFound\r\n  render json: { message: 'User not found' }, status: :user_not_found\r\nend\r\n```\r\n"],"correctAns":2}]