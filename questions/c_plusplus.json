[{"query":"What is the output of this piece of code?","code":"cpp\r\nint8_t a=200;\r\nuint8_t b=100;\r\nstd::cout<<\"a=\"<<(int)a;\r\nstd::cout<<\", b=\"<<(int)b;","options":["a=-56, b=100","a=-55, b=100","a=200, b=-156","a=200, b=100"],"correctAns":1},{"query":"What is an appropriate way of removing `my_object` as shown below?","code":"cpp\r\nmy_class *my_object = new my_class();","options":["`delete(my_object);`","`free(my_object);`","The garbage collector will destroy the object eventually.","Exiting the scope will destroy the object."],"correctAns":1},{"query":"What is the correct way to call the `count` member function for the object pointer called `grades`?","code":"cpp\r\nclass my_array{\r\n    public:\r\n        int count();\r\n};  // ... more members above\r\n\r\nint main(){\r\n    my_array *grades = new my_array();\r\n};  // ... more code above","options":["`grades.count();`","`my_array->count();`","`grades->count();`","`my_array.count();`"],"correctAns":3},{"query":"What would be the output of this code?","code":"cpp\r\nint i0=4, i1=6, i2=8;\r\nint& nums[3]={i2,i0,i1};\r\nstd::cout<<nums[0]<<nums[1]<<nums[2];","options":["There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.","846","The output is the addresses of `i2`, `i0`, and `i1`, in that order, with no spaces.","468"],"correctAns":1},{"query":"Does this code cause a compiler error? If so, why, and if not, what is `child_t`?","code":"cpp\r\ntypedef struct{\r\n    unsigned int  age    : 4;\r\n    unsigned char gender : 1;\r\n    char                 : 0;\r\n    unsigned int  size   : 2;\r\n}child_t;","options":["Yes, it causes a compiler error because the colon character is not allowed in struct definitions.","and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.","Yes, it causes a compiler error because there is an unnamed field.","Yes, it causes a compiler error because one field is defined as having a size of 0."],"correctAns":2},{"query":"What is this expression equivalent to?","code":"cpp\r\nA->B->C->D","options":["`A.B.C.D`","`*A.*B.*C.*D`","`&A.&B.&C.&D`","`*(*((*A).B).C).D`"],"correctAns":4},{"query":"What does this function do?","code":"cpp\r\nauto buff = new char[50];\r\nstd::memset(buff,20,50);","options":["It declares a memory buffer named buff that starts at address 20 and ends at address 70.","It sets all bits in the array named buffer from its element at index 20 to its element at index 50.","It writes the value 20 in every memory address from buff to buff+49.","It declares a memory buffer named buff that starts at address 20 and ends at address 50."],"correctAns":3},{"query":"Consider a class named `CustomData`. Which choice is a correct declaration syntax to overload the postfix `++` operator as a class member?","options":["`CustomData& operator++();`","`void operator++(CustomData);`","`CustomData operator++(CustomData);`","`CustomData operator++(int);`"],"correctAns":4},{"query":"You want to sort my_array, declared below. Which choice is the correct call to std::sort, using a lambda expression as the comparison function?","code":"cpp\r\nstd::array<uint32_t, 50> my_array;","options":["std::sort(my_array.begin(), my_array.end(),\r\n    [](uint32_t a, uint32_t b) {\r\n        return a < b;\r\n    })","lambda(uint32_t a, uint32_t b){\r\n    return a < b;\r\n}\r\nstd::sort(my_array.begin(), my_array.end(), lambda);","std::sort(my_array.begin(), my_array.end(),\r\n    lambda(uint32_t a, uint32_t b){\r\n        return a < b;\r\n    })","lambda(uint32_t a, uint32_t b){\r\n    return a < b;\r\n}\r\nstd::sort(my_array.begin(), my_array.end(), &lambda);"],"correctAns":1},{"query":"Which choice is the most reasonable implementation of the function std::mutex::lock() by using std::mutex::try_lock()?","code":null,"options":["void std::mutex::lock(){\r\n    while(!this->try_lock());\r\n}","void std::mutex::lock(){\r\n    return (this->try_lock());\r\n}","void std::mutex::lock(){\r\n    while(1)\r\n        this->try_lock();\r\n}","void std::mutex::lock(){\r\n    while(this->try_lock());\r\n}"],"correctAns":1},{"query":"What is the purpose of a destructor?","options":["It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.","It deletes an object. One example of a destructor is the `delete()` function.","It terminates a program. This may be achieved as a regular function call or as an exception.","There are no destructors in C++."],"correctAns":1},{"query":"Which STL class is the best fit for implementing a phonebook? Suppose each entry contains a name and a phone number, with no duplicates, and you want to have lookup by name.","options":["`std::priority_queue`","`std::map`","`std::vector`","`std::list`"],"correctAns":2},{"query":"What is the main difference between these two Functions?","code":"cpp\r\nstd::mutex::lock()\r\nstd::mutex::try_lock()","options":["`lock()` has a higher privilege over `try_lock()`. This means that you have a better chance of acquiring a mutex `with lock()`.","Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.","`lock()` enforces preemption, whereas `try_lock()` suggests preemption.","If the mutex is not available, `try_lock()` returns with a corresponding code, whereas `lock()` snatches the mutex from the thread that currently has it."],"correctAns":2},{"query":"What is one benefit of declaring the parameter as a `const` reference instead of declaring it as a regular object?","code":"cpp\r\nint median(const my_array& a)","options":["Actually, objects cannot be passed as regular variables, because they require a constructor call. Therefore, a `const` reference is the only way to pass class instances to functions.","There are no benefits because a reference and an object are treated as the same thing.","The `const` qualifier Forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged.","The argument is passed as a reference, so the Function receives a copy that can be modified without affecting the original variable.\r\n\r\nNote: This one is similar to Q6, but focuses on the `const` keyword."],"correctAns":3},{"query":"What is an include guard?","options":["a preprocessor directive that prevents inconsistent behaviors in lines that contain the #ifdef, #ifndef, or #elif directives","a compiler option that prevents the user code from including additional libraries","a preprocessor statement that prevents a source file from being included more than once in a project","a library that adds safety features such as mutexes, watchdog timers, and assertions to the project"],"correctAns":3},{"query":"What would be the correct declaration of a default constructor for a class named Sprite?","code":null,"options":[" public:\r\n    \t\tSprite();\r\n  "," private:\r\n    \t\tvoid Sprite();\r\n  "," public:\r\n    \t\tvoid Sprite();\r\n  ","    private:\r\n    \t\tSprite();\r\n  "],"correctAns":1},{"query":"What is the purpose of this line in a header file?","code":"cpp\r\n#pragma once","options":["to restrict the use of its contents to only one source file","to tell the compiler that only one variable can be instantiated from the classes or types contained in this header file","to help the compiler finish faster by assuring that only one compiler pass is neccessary for the code included in this header file","to make the compiler parse that header file only once, even if it is included multiple times in the source"],"correctAns":4},{"query":"What is a variable of type double?","options":["a 2-tuple","an integer number","a floating point number","a string with more than 255 characters"],"correctAns":3},{"query":"Consider this function declaration of is_even, which takes in an integer and returns true if the argument is an even number and false otherwise. Which declarations are correct for overloaded versions of that function to support floating point numbers and string representations of numbers?","code":"cpp\r\nbool is_even(int);","options":["bool is_even(float f); bool is_even(char \\*str);","bool is_even(float f); bool is_even(char str);","bool is_even_float(float f); bool is_even_str(char \\*str);","float is_even(float f); char *is_even(char *str);"],"correctAns":1},{"query":"Other than shifting bits to the left, what is the << oprator used for ?","options":["shifting characters to the left in a string.","inserting characters into an output stream like std::cout.","comparing floating point numbers as less-than.","assigning a variable to a reference."],"correctAns":2},{"query":"Does this code cause a compiler error? If so, why, and if not, what is `child_t`?","code":"cpp\r\ntypedef struct{\r\n    unsigned int  age    : 4;\r\n    unsigned char gender : 1;\r\n    char                 : 0;\r\n    unsigned int  size   : 2;\r\n}child_t;","options":["Yes, it causes a compiler error because the colon character is not allowed in struct definitions.","and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.","Yes, it causes a compiler error because there is an unnamed field.","Yes, it causes a compiler error because one field is defined as having a size of 0."],"correctAns":2},{"query":"Which choice is a reason to specify the type of a pointer instead of using `void *`, which works as a pointer ro any type?","options":["The compiler needs the dara type to make sure that the pointer is not going to be used on illegal non-pointable types such as functions, labels, pointers, and reference.","`void *` does not work for any type. The language does not allow assigning anything other than `void` to a pointer to `void *`.","The compiler needs the data type to know how much memory to allocate for the pointer, because different data types require different pointer lengths.","Yes, it causes a compiler error because one field is defined as having a size of 0."],"correctAns":3}]